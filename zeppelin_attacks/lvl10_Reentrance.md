# Level 10 - Re-entrancy

### Goal
Steal all the funds from the contract.

### Approach
When making calls to external addresses (for example when sending value) we always need be very cautious of how these can be handled (these addresses can be contracts, and these contracts can iniate functions based on value coming in). Especially, when we are using .call.value. This is because in this case the sender can specify the gas limit, allowing the called upon fallback function to do more than just send value and emit an event. For example, the fallback function could initiate a new call to our contract... This is how re-entrancy happens. Before our call to the external contract is finished and thus we move on to update the balance, the contract being called can send another withdraw() call, and another, and another, before that contract's balance is updated by the state change and untill our contract's balance is empty.
What we want to do in order to empty out this contract is 1. make sure that the contract that is going to perform the attack has value mapped to its address in the balances mapping (we do this by donate() an amount), 2. set up a withdrawAtt(_amount) function in our contract that calls the withdraw(_amount) method of the Reentrance contract submitting an amount to withdraw, and 3. set up a fallback function that initiates our withdrawAtt() function with a set amount (e.g. withdrawAtt(0.3 ether)). The moment we call our withdrawAtt function and set the gas limit to something high like 4000000, it will call the withdraw() function of the Reentrance contract. The contract will check if we have the money to withdraw _amount (and we should given that we have donated earlier to this address) and will then send ether to our malicious contract using the call.value method. This will iniate our fallback function, which will iniate our withdrawAtt(), which will re-enter the Reentrance contract again BEFORE it has been able to update our balance. This goes on till we have emptied out the contract.